<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>

</body>

</html>
<script>
	// 1原型链继承	
	function Person() {
		this.name = "hello world"
	}
	Person.prototype.getName = function () {
		console.log(this.getName)
	}

	function Child() {

	}

	Child.prototype = new Person()
	var child1 = new Child()
	child1.getName()

	// 重点 让新实例的原型等于父类的实例
	// 有点：实例可继承的属性有：实例构造函数的属性，父类原型的属性（新实例不会继承父类实例的属性）
	// 缺点：1、新实例无法向父类构造函数传参
	// 2、继承单一
	// 3、所有新实例都会共享父类实例的属性，原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改



	// 构造函数继承
	function Person() {
		this.name = 'xiaoming';
		this.colors = ['red', 'blue', 'green'];
	}
	Person.prototype.getName = function () {
		console.log(this.name);
	}

	function Child(age) {
		Person.call(this);
		this.age = age;
	}
	var child1 = new Child(23)
	var child2 = new Child(12);
	child1.colors.push('yellow')
	console.log(child1.name); //xiaoming
	console.log(child1.colors); //"red","blue","green","yellow"]
	console.log(child2.colors); //["red","blue","green"]


	// 重点：用.call)和.apply)将父类构造函数引入子类函数（在子类函数中做了父类函数的
	// 自执行（复制）)
	// 优点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
	// 2、解决了原型链继承缺点1、2、3。
	// 3、可以继承多个构造函数属性(cal多个)。
	// 4、在子实例中可向父实例传参。
	// 缺点：1、只能继承父类构造函数的属性。
	// 2、无法实现构造函数的复用。（每次用每次都要重新调用）
	// 3、每个新实例都有父类构造函数的副本，臃肿。



	// 3.组合继承（组合原型链继承和借用构造函数继承）（常用）

	function Parent(name) {
		this.name = name;
		this.colors = ['red', 'blue', 'green'];
	}
	Parent.prototype.getName = function () {
		console.log(this.name);
	}
	function Child(name, age) {
		Parent.call(this, name); //第2次调用 Parent()
		this.age = age;
	}

	Child.prototype = new Parent(); //第一次调用 Parent()

	var child1 = new Child("xioapao", 18)
	child1.getName() //xioapao
	var child2 = new Child("lulu", 19)


	// 重点：结合了两种模式的优点，传参和复用
	// 优点:1可以继承父类原型上的属性，可以传参，可复用
	// 2、每个新实例引入的构造函数属性是私有的
	// 缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数



</script>